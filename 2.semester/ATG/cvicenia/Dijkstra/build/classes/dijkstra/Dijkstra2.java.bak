package dijkstra;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

public class Dijkstra2 {
  /**
   * Matica incidencií
   */
  private Map<String, Map<String, Integer>> matrix
    = new HashMap<String, Map<String, Integer>>();

  /**
   * Mapa minimalnych vzdialenosti
   */
  private Map<String, Integer> distances = new HashMap<String, Integer>();
  
  //Ukladanie dlzky najkratsej cesty
  int possiblyBetterDistance;

  private void addNode(String newNode) {
    // na koniec kazdeho zoznamu prida mapovanie node->0
    for(Map<String, Integer> row : matrix.values()) {
      row.put(newNode, 0);
    }

    // prida novy zoznam dlzky pocetUzlov + 1 plny nul
    Map<String, Integer> list = new HashMap<String, Integer>();
    for(String n : matrix.keySet()) {
      list.put(n, 0);
    }
    list.put(newNode, 0);

    matrix.put(newNode, list);
  }

  protected void removeNode(String node) {
    matrix.remove(node);
    for (Map<String, Integer> row : matrix.values()) {
      row.remove(node);
    }
  }

  public void addEdge(String node1, String node2, int weight) {
    if(!matrix.containsKey(node1)) {
      addNode(node1);
    }

    if(!matrix.containsKey(node2)) {
      addNode(node2);
    }

    matrix.get(node1).put(node2, weight);
    //  pre neorientovane hrany tiez 
    matrix.get(node2).put(node1, weight);
  }

  public Set<String> getNodes() {
    return matrix.keySet();
  }

  public List<String> findPath(String sourceNode, String destinationNode) {
    for (String node : getNodes()) {
      distances.put(node, Integer.MAX_VALUE);
    }
    distances.put(sourceNode, 0);

    Map<String, String> predecessors = new HashMap<String, String>();
    String currentNode = null;
    while((currentNode = findNearestNode()) != null) {
      for (String adjacentNode : findAdjacentNodes(currentNode)) {
        possiblyBetterDistance = distances.get(currentNode)
          + distance(currentNode, adjacentNode); 
        if(possiblyBetterDistance < distances.get(adjacentNode)) {
          distances.put(adjacentNode, possiblyBetterDistance);
          predecessors.put(adjacentNode, currentNode);
        }
      }
      removeNode(currentNode);
      distances.remove(currentNode);
      System.out.println(possiblyBetterDistance);
    }
    List<String> path = new ArrayList<String>();
    String predecessor;
    String node = destinationNode;
    path.add(destinationNode);
    while((predecessor = predecessors.get(node)) != null) {
      path.add(0, predecessor);
      node = predecessor;
    }
    return path;
  }

  private String findNearestNode() {
    int minimum = Integer.MAX_VALUE;
    String nearestNode = null;
    for (Entry<String, Integer> entry : distances.entrySet()) {
      if(entry.getValue() < minimum) {
        minimum = entry.getValue();
        nearestNode = entry.getKey();
      }
    }
    return nearestNode;
  }

  private int distance(String node1, String node2) {
    return matrix.get(node1).get(node2);
  }

  private Set<String> findAdjacentNodes(String node) {
    Set<String> adjacentNodes = new HashSet<String>();
    for(Entry<String, Integer> item : matrix.get(node).entrySet()) {
      if(item.getValue() > 0) {
        adjacentNodes.add(item.getKey());
      }
    }
    return adjacentNodes;
  }

  public static void main(String[] args) {
    Dijkstra2 dijkstra = new Dijkstra2();
    dijkstra.addEdge("Bratislava", "Trnava", 5);
    dijkstra.addEdge("Trnava", "Nitra", 5);
    dijkstra.addEdge("Bratislava", "Nitra", 9);
    dijkstra.addEdge("Trnava", "Trenčín", 8);
    dijkstra.addEdge("Trenčín", "Žilina", 8);
    dijkstra.addEdge("Žilina", "Banská Bystrica", 9);
    dijkstra.addEdge("Žilina", "Prešov", 25);
    dijkstra.addEdge("Nitra", "Banská Bystrica", 13);
    dijkstra.addEdge("Prešov", "Košice", 3);
    dijkstra.addEdge("Banská Bystrica", "Košice", 25);
    dijkstra.addEdge("Bratislava", "Banská Bystrica", 22);

    for (String entry : dijkstra.findPath("Bratislava", "Košice")) {
      System.out.println(entry);
    }
  }
}